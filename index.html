<html lang="pt_BR">

    <head>
        <meta charset="utf-8"/>
        <title>Trabalho Grafos</title>

        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-+0n0xVW2eSR5OomGNYDnhzAbDsOXxcvSN1TPprVMTNDbiYZCxYbOOl7+AMvyTG2x" crossorigin="anonymous">
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/js/bootstrap.bundle.min.js" integrity="sha384-gtEjrD/SeCtmISkJkNUaaKMoLD0//ElJ19smozuHV6z3Iehds+3Ulb9Bn9Plx0x4" crossorigin="anonymous"></script>

        <style>
            body {
                background-color: #060D0F;
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            .board {
                margin: 10px;
                background-color: #0C191D;
                border: 5px solid #0C191D;
                border-radius: 5px;
                color: white;
                width: fit-content;
            }

            .board .panel {
                margin: 10px;
                display: flex;
            }

            .board .center {
                display: flex;
                justify-self: center;
            }

            .board canvas {
                margin: 10px;
                background-color: #11262C;
                border: 5px solid #11262C;
                border-radius: 5px;
            }

            .board .instructions {
                margin: 10px;
                padding: 10px;
                background-color: #11262C;
                border: 5px solid #11262C;
                border-radius: 5px;
            }
        </style>
    </head>

    <body>
        <div class="top">
        </div>
        <div class="board">
            <div class="panel">
                <button type="button" class="btn btn-danger">Limpar grafo</button>
                <div class="flex-grow-1"></div>
                <h3>Criação de Grafos</h3>
                <div class="flex-grow-1"></div>
                <button type="button" class="btn btn-success">Continuar</button>
            </div>
            <div class="center">
                <canvas id="canvas" width="600" height="600"></canvas>
                <div class="instructions">
                    <h4>Instruções:</h4>
                    <p>
                        Botão Esquerdo do Mouse: Cria e/ou seleciona vertices
                        <br>
                        Botão Direito do Mouse: Deleta vertices
                        <br>
                        Shift + Botão Esquerdo do Mouse: Cria uma aresta entre dois vertices.
                        <br>
                        Shift + Botão Direito do Mouse: Deleta uma aresta entre dois vertices
                        <br>
                        +: Aumenta o valor do vertice selecionado
                        <br>
                        -: Diminui o valor do vertice selecionado
                    </p>
                </div>
            </div>
        </div>
    </body>

    <script>
        const verticeSize = 30

        class Vertice {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.value = 0
            }

            isColliding(vertice) {
                let distSq = (this.x - vertice.x) * (this.x - vertice.x) + (this.y - vertice.y) * (this.y - vertice.y);
                let radSumSq = verticeSize * verticeSize;
                return (distSq !== radSumSq && distSq <= radSumSq)
            }

            isPointInside(x, y) {
                return (x - this.x)*(x - this.x) + (y - this.y)*(y - this.y) <= (verticeSize/2)*(verticeSize/2)
            }
        }

        class Edge {
            constructor(vertice1, vertice2, directed) {
                this.vertice1 = vertice1
                this.vertice2 = vertice2
                this.directed = directed
            }

            isEqual(edge) {
                return (this.vertice1 === edge.vertice1 && this.vertice2 === edge.vertice2) || (this.vertice2 === edge.vertice1 && this.vertice1 === edge.vertice2)
            }
        }

        class Graph {
            constructor(onUpdate) {
                this.vertices = []
                this.edges = []
                this.onUpdate = onUpdate
            }

            getVertice(x, y) {
                let vertice = null
                this.vertices.forEach((v) => {
                    if(v.isPointInside(x, y)) {
                        vertice = v
                        this.onUpdate()
                    }
                })
                return vertice
            }

            addVertice(vertice) {
                let colliding = this.isVerticeColliding(vertice)
                if(!colliding) {
                    this.vertices.push(vertice)
                    this.onUpdate()
                }
                return !colliding
            }

            removeVertice(vertice) {
                const index = this.vertices.indexOf(vertice);
                if (index > -1) {
                    this.vertices.splice(index, 1);
                    let edgesToRemove = []
                    this.edges.forEach((e) => {
                        if(vertice === e.vertice1 || vertice === e.vertice2) {
                            edgesToRemove.push(e)
                        }
                    })
                    edgesToRemove.forEach((e) => {
                        this.removeEdge(e)
                    })
                }
            }

            isVerticeColliding(vertice) {
                let colliding = false
                this.vertices.forEach((v) => {
                    if(v !== vertice && v.isColliding(vertice)) {
                        colliding = true
                    }
                })
                return colliding
            }

            getEdge(vertice1, vertice2) {
                let edge = null
                let equalEdge = new Edge(vertice1, vertice2)
                this.edges.forEach((e) => {
                    if(e.isEqual(equalEdge)) {
                        edge = e
                    }
                })
                return edge
            }

            addEdge(edge) {
                let colliding = false
                this.edges.forEach((e) => {
                    if(e.isEqual(edge)) {
                        colliding = true
                    }
                })
                if(!colliding) {
                    this.edges.push(edge)
                    this.onUpdate()
                }
                return !colliding
            }

            removeEdge(edge) {
                const index = this.edges.indexOf(edge);
                if (index > -1) {
                    this.edges.splice(index, 1);
                }
            }
        }

        const canvas = document.getElementById("canvas");
        const rect = canvas.getBoundingClientRect();
        const context = canvas.getContext("2d");
        let onCanvas = false

        const graph = new Graph(updateCanvas)
        let selectedVertice = null
        let draggingVertice = null
        let drawingEdge = null

        document.body.oncontextmenu = function (event) {
            if(onCanvas) {
                event.preventDefault()
            }
        }

        document.body.onmousedown = function (event) {
            if(onCanvas) {
                let vertice = graph.getVertice(event.x - rect.left, event.y - rect.top)
                if(event.button === 0) {
                    if (event.shiftKey) {
                        if (vertice != null && selectedVertice != null && vertice !== selectedVertice) {
                            graph.addEdge(new Edge(selectedVertice, vertice))
                            drawingEdge = null
                        }
                    } else {
                        draggingVertice = vertice
                        selectedVertice = vertice
                    }
                }else if(event.button === 2) {
                    if (event.shiftKey) {
                        if(vertice != null && selectedVertice != null && vertice !== selectedVertice) {
                            let edge = graph.getEdge(selectedVertice, vertice)
                            if(edge != null) {
                                graph.removeEdge(edge)
                            }
                        }
                    } else {
                        graph.removeVertice(vertice)
                    }
                }
                updateCanvas()
            }
        }

        document.body.onmouseup = function (event) {
            if(onCanvas) {
                if(event.button === 0) {
                    if(draggingVertice != null) {
                        draggingVertice = null
                    }else if (graph.getVertice(event.x - rect.left, event.y - rect.top) == null) {
                        let vertice = new Vertice(event.x - rect.left, event.y - rect.top)
                        let created = graph.addVertice(vertice)
                        if(created) {
                            selectedVertice = vertice
                        }
                    }
                }
                updateCanvas()
            }
        }

        document.body.onmousemove = function (event) {
            if(event.x >= rect.left && event.x <= rect.right && event.y >= rect.top && event.y <= rect.bottom) {
                onCanvas = true
                if(draggingVertice != null) {
                    let backupX = draggingVertice.x
                    let backupY = draggingVertice.y
                    draggingVertice.x = event.x - rect.left
                    draggingVertice.y = event.y - rect.top
                    if(graph.isVerticeColliding(draggingVertice)) {
                        draggingVertice.x = backupX
                        draggingVertice.y = backupY
                    }
                }else if(selectedVertice != null && event.shiftKey) {
                    drawingEdge = new Edge(selectedVertice, new Vertice(event.x - rect.left, event.y - rect.top))
                }else{
                    drawingEdge = null
                }
                updateCanvas()
            }
        }

        document.body.onkeypress = function (event) {
            switch (event.key) {
                case '+':
                    if(selectedVertice != null) {
                        selectedVertice.value++
                    }
                    break
                case '-':
                    if(selectedVertice != null) {
                        selectedVertice.value--
                    }
                    break
                default:
                    break
            }
            updateCanvas()
        }

        function clearCanvas() {
            context.fillStyle = "#11262C"
            context.rect(0, 0, canvas.width, canvas.height)
            context.fill()
        }

        function drawEdge(edge) {
            context.strokeStyle = "#D6FFFC"
            context.beginPath()
            context.moveTo(edge.vertice1.x, edge.vertice1.y)
            context.lineTo(edge.vertice2.x, edge.vertice2.y)
            context.closePath()
            context.stroke()
        }

        function drawVertice(vertice) {
            context.fillStyle = "#00BFB3"
            context.beginPath()
            context.arc(vertice.x, vertice.y, verticeSize/2, 0, 2*Math.PI)
            context.closePath()
            context.fill()
            context.fillStyle = "#D6FFFC"
            context.font = "16px sans-serif"
            context.textAlign = "center"
            context.textBaseline = "middle"
            context.fillText(vertice.value, vertice.x, vertice.y)
            if(vertice === selectedVertice) {
                context.strokeStyle = "#D6FFFC"
                context.stroke()
            }
        }

        function updateCanvas() {
            clearCanvas()
            if(drawingEdge != null) {
                drawEdge(drawingEdge)
            }
            graph.edges.forEach((edge) => {
                drawEdge(edge)
            })
            graph.vertices.forEach((vertice) => {
                drawVertice(vertice)
            })
        }

        context.lineWidth = 3
        updateCanvas()

    </script>

</html>